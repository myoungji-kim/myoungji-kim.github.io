---
title: "Ch 08. 프로그래밍 언어 처리"
excerpt: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍]"

categories:
  - Book (직접 노출 X)
# tags:
#   - [tag1, tag2]

permalink: /book/finish+computer+programming+with+one+book/ch+08

toc: true
toc_sticky: true

date: 2022-09-15
last_modified_at: 2022-09-15

---
컴퓨터는 프로그램을 어떻게 해석하고 변환하는가? <br> <br>

> 책의 내용을 공부한 뒤, 제 나름대로 풀어서 정리한 포스팅입니다.

### 🧩 <b>기계어</b>

기계어는 컴퓨터(의 CPU)가 직접적으로 사용하는 언어!
1000 1011 과 같은 2진법으로 구성되어 있다.

모든 컴퓨터는 결국 이진법 구성된 코드를 읽고 작업을 실행하겠지만,
0과 1로 수도 없이 나열된 코드를 우리 같은 일반인이 보기에는 너무 어렵다..

사람이 직접 기계어로 프로그래밍을 한다?
나였으면 진작에 뇌에 과부하가 와서 도망갔을지도..ㅎ

그래서 기계어보다 좀더 쉽게 프로그래밍하기 위해 등장한 언어가 있는데!


### 🧩 <b>어셈블리어</b>

초기 프로그래머들이 0, 1에 진절머리 나서(?) 프로그램을 작성하는 더 나은 방법을 찾았다. 그 해결책으로 나온 것이 '어셈블리어'!

어셈블리 언어를 사용하면서부터 비트 조합이 아닌, 니모닉으로 명령어를 쓸 수 있게 되었다. (즉, 어셈블리어는 니모닉으로 구성되어있다.)

> 니모닉 : 'ADD 12'처럼 사람이 직접적으로 알아볼 수 있는 글자로 표현한 것

어셈블리 언어의 명령어 예시로는 load, store, add, again, bss 등이 있다. 
(bss는 메모리 덩어리를 예약하되, 메모리 안에는 아무 값도 넣지 않는 명령어를 의미한다)

어셈블리어를 사용한다고 해도, 컴퓨터가 이해하기 위해서는 결국 이진법으로 변경해야 하는데, 이때 어셈블리 언어로 작성된 코드를 기계어 코드로 생성해주는 프로그램을 '어셈블러'라고 한다.

이렇게 초창기 프로그래머들은 기계어에서 탈출해 조금은 행복하게 프로그래밍을 할 수 있게 되었다. 어셈블리 언어를 시작으로, 더 개선된 의사명령어들을 계속 만들어갔다. 

* '부트스트랩(=부트)'이라는 말이 여기서 생겨났는데, 컴퓨터를 부팅하면 ROM 등에 있는 작은 프로그램을 메모리로 읽어오는 것부터 시작한다. 이 프로그램은 필요한 초기화를 진행하면서 계속 더더욱 큰 프로그램, 운영체제 등을 불러오게 된다. 초기 컴퓨터는 사람이 직접 패널의 스위치를 사용해서 최초 부트스트랩 프로그램을 입력해야 했다.



### 🧩 <b>고수준 언어</b>
어셈블리 언어는 초창기 프로그래머들에게 기쁨을 가져다줬지만, 그래도 더 복잡한 작업을 할 때 더욱 적은 단어를 쓰면 훨씬 행복해질 것이다. 

그래서 등장한 '고수준 언어'!
고수준 언어는 어셈블리어보다 더 높은 추상화 단계에서 작동한다. 

어셈블러가 어셈블리 언어를 보고 기계어 코드로 번역해줬다면,
고수준 언어는 '컴파일러'가 기계어로 번역해준다.

처음 생긴 고수준 언어는 '포트란', 즉 '식 변환기'이다.

```
I = 0
J = 1
K = I + J

I = J
J = K

IF ( J .LT. 200 ) GOTO 5
```

훨씬 깔끔하고 단순해졌다!
포트란의 아이디어를 받아들여 변형한 또 다른 언어는 '베이직'이 있다.

* 참고 : goto문은 조건 없이 바로 어떤 위치로 점프하게 하는 문장


### 🧩 <b>구조적 프로그래밍</b>

위에서 언급한 포트란, 베이직 언어는 '비구조적 언어'이다.
GOTO와 레이블을 조합할 때 아무런 구조를 강요받지 않았기 때문인데,
GOTO를 잘못 남발해 스파게티 코드가 되는 것을 해결하기 위해 '구조적 프로그래밍'이 등장했다.

대표적인 언어로 C, C++, 자바, PHP, 파이썬, 자바스크립트 등이 있다.
모두 명시적인 분기를 사용하지 않는 프로그래밍 언어에 해당한다.

``` js
var first; // 첫 번째 수
var second; // 두 번째 수
var next; // 수열의 다음 수

first = 0;
second = 1;

while ((next = first + second) < 200>) {
    // 수를 가지고 뭔가 재미있는 일을 함
    first = second;
    second = next;
}
```

깔끔해진 제어 흐름 덕분에 프로그램 이해가 더 쉬워졌다.


### 🧩 <b>어휘 분석</b>

위에서는 계속 프로그래밍을 더 쉽게 하기 위한 개발자들의 노력을 살펴봤다.
지금부터는 '언어를 처리하는 방식'에 대해서 알아보려고 한다.

> 어휘 분석 : 코드를 기호(문자들)로부터 단어와 같은 성격의 토큰으로 변환하는 과정

'DDing Ji'
2개의 토큰('DDing', 'Ji')과 1개의 구분자(공백)로 이뤄진다.
이를 구분하는 알고리즘을 만들기 위해 토큰 버퍼를 비우고 문자를 얻어와서 구분자인지 체크하고 문자를 추가해주는 등.. 
여러가지 경우를 체크해야 한다. 

간단한 문자더라도 알고리즘을 생각하면 복잡해지는데,
연산자, 피연산자, 공백까지 고려하는 수를 생각하면 더 머리가 지끈거린다.
(책 325페이지에서 언급한 부동소수점 수에 대한 도해를 보면 알 수 있다.)

수의 복잡성을 통해 언어 토큰을 추출하는 코드의 분량이 끝도 없이 늘어난다는 걸 알 수 있는데,
많은 상태들의 결합과 전이를 토대로 '상태 기계'를 만들 수 있게 된다.
(책 327페이지. 표 8-1 참고)

> 원리를 자세하게 이해하기 보다는, 입력과 상태를 조합해 결과를 도출하는 상태 테이블을 만들면 훨씬 확인이 쉬워진다는 정도로 보았다!



### 🧩 <b>정규식</b>

상태 테이블을 만들어둠으로써 결과를 찾아내기 좀더 쉬워졌지만,
사실 만들기까지의 과정은 매우 복잡하고 지루할 것이다. (실수를 할 수도 있고!)

'스티븐 콜 클레이니'라는 수학자가 더 간편한 방법을 내세웠는데, 언어를 지정하기 위한 언어를 정의한 것이다. 이는 오늘날 많은 사람들이 사용하고 있으며 대부분의 프로그래밍 언어에서도 사용되고 있는 '정규식'이다.

처음에 정규식을 보면 되게 복잡해보이는데, 사실 몇가지 규칙에 의존하는 간단한(?) 식이다. (책의 내용보다 ![시각적으로 잘 정리해둔 포스팅](https://yurimkoo.github.io/analytics/2019/10/26/regular_expression.html) 이 있어서 이걸로 참고!)


### 🧩 <b>중간 정리</b>
잠-시 현재까지 살펴본 내용을 정리하고 넘어가보자.

컴퓨터는 0, 1로 이루어진 기계어만 읽을 수 있다.
그러나 프로그래머가 0, 1만으로 개발하기에는 너무 어렵기 때문에
더 나은 방법을 찾은 결과 어셈블리어, 고수준 언어까지 나왔다.

그러나 고수준 언어(ex. 포트란)는 '비구조적 언어'이기 때문에,
개발의 양이 많아졌을 때, 스파게티 코드가 될 수 있다는 문제점이 있다.

그래서 나오게 된 '구조적 언어'!
요즘 프로그래밍 언어는 대부분 구조적 언어에 해당한다. (C, C++, JS, 파이썬, PHP 등)
그리고 제어 흐름이 깔끔해졌기 때문에 프로그램을 더 쉽게 이해할 수 있게 되었다.

다음으로는 '언어를 처리'하는 방식에 대한 고민이 시작됐다.
어휘 분석을 통해 다이어그램을 그려 판단을 하거나, 상태 테이블과 같은 상태 기계를 만들어내기도 했는데 오늘날 가장 많이 쓰이는 방식은 언어로 언어를 처리한 '정규식'이다. 

이렇게 다양한 문자들을 '단어'로 처리하는 방법까지 터득했다.
하지만 우리가 언어를 사용할 때는 단어가 아닌, 단어와 '문법'이 적절하게 사용된 문장을 보기 때문에.. 이제부터 '문장'을 처리하는 방법으로 넘어가보자!


### 🧩 <b>단어에서 문장으로</b>

사칙 연산기를 예로 들면
4 + 12는 문법에 맞지만, 4 + + + 1 + + 2는 문법에 맞지 않는다.
이제는 패턴 매칭까지 고려를 해줘야 한다는 뜻이다.

그리고 이에 대해 고민한 사람이 '스티븐 C 존슨'인데, 1970년대 초반에 yacc라는 프로그램을 작성했다. yacc가 만들어내는 프로그램은 스택을 사용하는 시프트-리듀스 파서다.

> 시프트 : 토큰을 스택에 넣는다 <br>
> 리듀스 : 스택의 맨 위부터 매치된 토큰들을 다른 것으로 대치한다 (결과값 도출) <br>

